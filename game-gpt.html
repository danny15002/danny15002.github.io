<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Red Circle Clicker</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        background: #111;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    canvas {
        background: #222;
        display: block;
    }
    #restartBtn {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
        font-size: 20px;
        background: #ff4444;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        display: none;
    }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<button id="restartBtn">Restart</button>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const restartBtn = document.getElementById("restartBtn");

let lives, level, score, enemies, enemyCount, spawnDelay, enemySpeed, lastSpawn, enemyRadius, gameOver;
let displayWidth, displayHeight;

function resizeCanvas() {
    const scale = window.devicePixelRatio || 1;
    const aspect = 9 / 16;

    if (window.innerWidth / window.innerHeight > aspect) {
        // Too wide — fit height
        displayHeight = window.innerHeight;
        displayWidth = displayHeight * aspect;
    } else {
        // Too tall — fit width
        displayWidth = window.innerWidth;
        displayHeight = displayWidth / aspect;
    }

    canvas.style.width = displayWidth + "px";
    canvas.style.height = displayHeight + "px";

    canvas.width = displayWidth * scale;
    canvas.height = displayHeight * scale;

    ctx.setTransform(scale, 0, 0, scale, 0, 0); // Reset scaling for new size

    enemyRadius = displayHeight * 0.02; // 2% of height
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

function initGame() {
    lives = 1000;
    level = 1;
    score = 0;
    gameOver = false;
    enemies = [];
    setupLevel();
}

function setupLevel() {
    enemyCount = 20 + Math.floor((level - 1) / 5) * 5;
    enemySpeed = displayHeight / 5 * Math.pow(1.03, level - 1);
    spawnDelay = 2000 * Math.pow(0.98, level - 1);
    lastSpawn = performance.now();
}

function spawnEnemy() {
    enemies.push({
        x: Math.random() * (displayWidth - enemyRadius * 2) + enemyRadius,
        y: 0,
        radius: enemyRadius
    });
}

function update(dt) {
    if (gameOver) return;

    const now = performance.now();
    if (enemyCount > 0 && now - lastSpawn >= spawnDelay) {
        spawnEnemy();
        enemyCount--;
        lastSpawn = now;
    }

    // Move enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemySpeed * (dt / 1000);
        if (enemies[i].y - enemies[i].radius >= displayHeight) {
            lives--;
            enemies.splice(i, 1);
            if (lives <= 0) {
                gameOver = true;
                restartBtn.style.display = "block";
            }
        }
    }

    // Check for level complete
    if (enemyCount === 0 && enemies.length === 0 && !gameOver) {
        level++;
        setupLevel();
    }
}

function draw() {
    ctx.clearRect(0, 0, displayWidth, displayHeight);

    // HUD
    ctx.fillStyle = "white";
    ctx.font = "20px Arial";
    ctx.fillText(`Level: ${level}`, 10, 25);
    ctx.fillText(`Score: ${score}`, 10, 50);
    const text = `Lives: ${lives}`;
    const textWidth = ctx.measureText(text).width;
    ctx.fillText(text, displayWidth - textWidth - 10, 25);

    // Enemies
    ctx.fillStyle = "red";
    for (const e of enemies) {
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.fill();
    }

    // Game Over
    if (gameOver) {
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", displayWidth / 2, displayHeight / 2 - 40);
        ctx.textAlign = "left";
    }
}

function gameLoop(timestamp) {
    if (!lastFrameTime) lastFrameTime = timestamp;
    const dt = timestamp - lastFrameTime;
    lastFrameTime = timestamp;

    update(dt);
    draw();

    requestAnimationFrame(gameLoop);
}

let lastFrameTime = 0;

function handleClick(e) {
    if (gameOver) return;
    const rect = canvas.getBoundingClientRect();
    const clickX = (e.clientX - rect.left) * (displayWidth / rect.width);
    const clickY = (e.clientY - rect.top) * (displayHeight / rect.height);

    for (let i = enemies.length - 1; i >= 0; i--) {
        const dx = clickX - enemies[i].x;
        const dy = clickY - enemies[i].y;
        if (Math.sqrt(dx * dx + dy * dy) <= enemies[i].radius) {
            score++;
            enemies.splice(i, 1);
            break;
        }
    }
}

canvas.addEventListener("click", handleClick);
canvas.addEventListener("touchstart", function (e) {
    const touch = e.touches[0];
    handleClick({ clientX: touch.clientX, clientY: touch.clientY });
});

restartBtn.addEventListener("click", () => {
    restartBtn.style.display = "none";
    initGame();
});

initGame();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
